# Algoritmos e Estruturas de Dados I

- 01_Registro: Usando como base o código dado pela professora, com as funções insereAluno e listaAluno, criamos as funções removeAluno e buscaAluno. É um sistema em que podemos gerenciar alunos em uma sala de aula.
- 02_Ponteiros: 5 exercícios de uma lista de ponteiros:
  - ex17: Escreva uma função que dado um número real passado como parâmetro, retorne a parte inteira e a parte fracionária deste numero. Escreva um programa que chame esta função.
  - ex18: Implemente uma funcao que calcule a area da superficie e o volume de uma esfera de raio R.
  - ex20: Implemente uma função que receba como parâmetro um array de números reais de tamanho N e retorne quantos números negativos há nesse array.
  - ex24: Escreva uma função que receba um array de inteiros V e os endereços de duas variáveis inteiras, min e max, e armazene nessas variaveis o valor mínimo e máximo do array. Escreva tambem uma função main que use essa função.
  - ex26: Implemente uma função que calcule as raízes de uma equação do segundo grau do tipo Ax^2 + Bx + C = 0.
- 03_AlocacaoDinamica: 4 exercícios de uma lista de alocação dinâmica:
  - ex01: Faça um programa que leia um valor n e crie dinamicamente um vetor de n elementos e passe esse vetor para uma função que vai ler os elementos desse vetor. Depois, no programa principal, o vetor preenchido deve ser impresso. Além disso, antes de finalizar o programa, deve-se liberar a área de memória alocada.
  - ex02: Faça uma função que receba um valor n e crie dinamicamente um vetor de n elementos e retorne um ponteiro. Crie uma função que receba um ponteiro para um vetor e um valor n e imprima os n elementos desse vetor. Construa também uma função que receba um ponteiro para um vetor e libere esta área de memória. Ao final, crie uma função principal que leia um valor n e chame a função criada acima. Depois, a função principal deve ler os n elementos desse vetor. Então, a função principal deve chamar a função de impressão dos n elementos do vetor criado e, finalmente, liberar a memória alocada através da função criada para liberação.
  - ex03: Construa um programa (main) que aloque em tempo de execução (dinamicamente) uma matriz de ordem m x n (linha por coluna), usando 1+m chamadas a função malloc. Agora, aproveite este programa para construir uma função que recebendo os parâmetros m e n aloque uma matriz de ordem m x n e retorne um ponteiro para esta matriz alocada. Crie ainda uma função para liberar a área de memória alocada pela matriz. Finalmente, crie um novo programa (main) que teste/use as duas funções criadas acima.
  - ex05: Criar um tipo abstrato de dados que represente uma pessoa, contendo nome, data de nascimento e CPF. Crie uma variável que é um ponteiro para este TAD (no programa principal). Depois crie uma função que receba este ponteiro e preencha os dados da estrutura e também uma uma função que receba este ponteiro e imprima os dados da estrutura. Finalmente, faça a chamada a esta função na função principal.
- 04_ListaLinearSE: Exercício sobre Lista Linear Sequencial Estática. Usando o código base da professora, implementamos as funções adicionaNaPosição, retiraDaPosição e retiraEspecífico.
- 05_ListaLinearED: Exercício sobre Lista Linear Encadeada Dinâmica. Usando o código base da professora, implementamos as funções adicionaNaPosição, retiraDaPosição e retiraEspecífico.
- 06_ArvoreGenerica: Implementar a impressão da árvore por parênteses aninhados
- 07_Prova2: Exercícios do Beecrowd que contaram como a nossa P2:
  - [1194](https://judge.beecrowd.com/en/problems/view/1194): Dadas as representações prefixas e infixas de uma árvore binária, compute sua representação posfixa.
  - [1195](https://judge.beecrowd.com/en/problems/view/1195): Dados x números de casos, y números em cada caso, monte as árvores de busca binárias equivalentes para cada caso e imprima a representação prefixa, infixa e posfixa.
  - [1200](https://judge.beecrowd.com/en/problems/view/1200): Monte um programa capaz de inserir letras em uma árvore de busca binária, checar se certas letras existem na árvore e imprimí-la em sua representação prefixa, infixa ou posfixa.
  - [1201](https://judge.beecrowd.com/en/problems/view/1201): Monte um programa capaz de inserir números inteiros em uma árvore de busca binária, checar se certos valores existem na árvore, remover certos valores da árvore e imprimí-la em sua representação prefixa, infixa ou posfixa.
  - [1466](https://judge.beecrowd.com/en/problems/view/1466): Dados x números de casos, y números em cada caso, monte as árvores de busca binárias equivalentes para cada caso e imprima a árvore em sua representação em camadas/níveis.
